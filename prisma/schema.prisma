generator client {
  provider        = "prisma-client"
  output          = "../app/generated/prisma"
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["slopwork"]
}

// --- Enums ---

enum TaskType {
  QUOTE
  COMPETITION
  CAMPAIGN

  @@schema("slopwork")
}

enum TaskStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  DISPUTED
  CANCELLED

  @@schema("slopwork")
}

enum BidStatus {
  PENDING
  ACCEPTED
  REJECTED
  FUNDED
  PAYMENT_REQUESTED
  COMPLETED
  DISPUTED

  @@schema("slopwork")
}

enum DisputeStatus {
  PENDING
  ACCEPTED
  DENIED

  @@schema("slopwork")
}

enum DisputeRaisedBy {
  CREATOR
  BIDDER

  @@schema("slopwork")
}

enum NotificationType {
  NEW_BID
  BID_ACCEPTED
  BID_REJECTED
  ESCROW_FUNDED
  PAYMENT_REQUESTED
  PAYMENT_APPROVED
  NEW_MESSAGE
  DISPUTE_RAISED
  DISPUTE_RESOLVED
  SUBMISSION_RECEIVED
  CAMPAIGN_SUBMISSION_APPROVED
  CAMPAIGN_SUBMISSION_REJECTED
  CAMPAIGN_PAYMENT_REQUEST
  CAMPAIGN_PAYMENT_COMPLETED
  CAMPAIGN_CREATOR_REJECTED

  @@schema("slopwork")
}

enum CampaignSubmissionStatus {
  PENDING_PAYMENT
  READING_VIEWS
  CHECKING_CONTENT
  APPROVED
  PAYMENT_REQUESTED
  REJECTED
  CREATOR_REJECTED
  PAID
  PAYMENT_FAILED

  @@schema("slopwork")
}

// --- Models ---

model User {
  id            String   @id @default(uuid())
  walletAddress String   @unique
  username      String?  @unique
  profilePicUrl String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // X (Twitter) account linking
  xUserId         String?   @unique
  xUsername        String?
  xAccessToken    String?
  xRefreshToken   String?
  xTokenExpiresAt DateTime?

  tasks                Task[]               @relation("TaskCreator")
  bids                 Bid[]                @relation("Bidder")
  sentMessages         Message[]            @relation("MessageSender")
  receivedMessages     Message[]            @relation("MessageRecipient")
  notifications        Notification[]       @relation("UserNotifications")
  campaignSubmissions  CampaignSubmission[] @relation("CampaignSubmitter")

  @@index([walletAddress])
  @@index([username])
  @@schema("slopwork")
}

model AuthNonce {
  id            String   @id @default(uuid())
  walletAddress String
  nonce         String   @unique
  expiresAt     DateTime
  createdAt     DateTime @default(now())

  @@index([walletAddress])
  @@index([expiresAt])
  @@schema("slopwork")
}

model Task {
  id                  String     @id @default(uuid())
  creatorId           String
  title               String
  description         String
  budgetLamports      BigInt
  taskType            TaskType   @default(QUOTE)
  status              TaskStatus @default(OPEN)
  paymentTxSignature  String     @unique
  multisigAddress     String?
  vaultAddress        String?
  winningBidId        String?    @unique
  deadlineAt          DateTime?
  imageUrl            String?
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt

  creator             User                @relation("TaskCreator", fields: [creatorId], references: [id])
  winningBid          Bid?                @relation("WinningBid", fields: [winningBidId], references: [id])
  bids                Bid[]               @relation("TaskBids")
  messages            Message[]
  campaignConfig      CampaignConfig?
  campaignSubmissions CampaignSubmission[]

  @@index([creatorId])
  @@index([status])
  @@index([createdAt])
  @@schema("slopwork")
}

model Bid {
  id               String    @id @default(uuid())
  taskId           String
  bidderId         String
  amountLamports   BigInt
  description      String
  multisigAddress  String?
  vaultAddress     String?
  fundingTxSig     String?
  proposalIndex    Int?
  paymentTxSig     String?
  status           BidStatus @default(PENDING)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  task             Task      @relation("TaskBids", fields: [taskId], references: [id])
  bidder           User      @relation("Bidder", fields: [bidderId], references: [id])
  wonTask          Task?     @relation("WinningBid")
  disputes         Dispute[]
  submissions      Submission[]

  @@unique([fundingTxSig])
  @@index([taskId])
  @@index([bidderId])
  @@index([status])
  @@schema("slopwork")
}

model Message {
  id          String   @id @default(uuid())
  taskId      String
  senderId    String
  recipientId String?  // The other party in the private conversation. Null for legacy public messages.
  content     String
  attachments Json?    // Array of { url, key, contentType, size, filename }
  createdAt   DateTime @default(now())

  task        Task     @relation(fields: [taskId], references: [id])
  sender      User     @relation("MessageSender", fields: [senderId], references: [id])
  recipient   User?    @relation("MessageRecipient", fields: [recipientId], references: [id])

  @@index([taskId, createdAt])
  @@index([senderId])
  @@index([recipientId])
  @@index([taskId, senderId, recipientId])
  @@schema("slopwork")
}

model Dispute {
  id               String          @id @default(uuid())
  bidId            String
  raisedBy         DisputeRaisedBy
  raisedByWallet   String
  proposalIndex    Int             // On-chain proposal index for this dispute
  proposalTxSig    String          // Tx signature of the proposal creation
  reason           String
  evidenceUrls     String[]        @default([])
  status           DisputeStatus   @default(PENDING)
  responseReason   String?         // Respondent's counter-argument
  responseEvidence String[]        @default([])
  resolutionNotes  String?
  resolvedByWallet String?
  resolveTxSig     String?         // If accepted: the arbiter's approve tx signature
  executeTxSig     String?         // If accepted: the execute tx signature
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  resolvedAt       DateTime?

  bid              Bid             @relation(fields: [bidId], references: [id])

  @@index([bidId])
  @@index([status])
  @@index([createdAt])
  @@schema("slopwork")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType
  title     String
  body      String
  linkUrl   String
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())

  user      User             @relation("UserNotifications", fields: [userId], references: [id])

  @@index([userId, read, createdAt])
  @@schema("slopwork")
}

model Submission {
  id          String   @id @default(uuid())
  bidId       String
  description String
  attachments Json?    // Array of { url, key, contentType, size, filename }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  bid         Bid      @relation(fields: [bidId], references: [id])

  @@index([bidId])
  @@schema("slopwork")
}

model CampaignConfig {
  id                      String @id @default(cuid())
  taskId                  String @unique
  cpmLamports             BigInt   // Cost per 1000 views in lamports
  budgetRemainingLamports BigInt   // Tracks remaining budget
  guidelines              Json     // { dos: string[], donts: string[] }
  minViews                Int    @default(100)
  minPayoutLamports       BigInt @default(0)  // Minimum cumulative payout before user can request payment

  task                    Task   @relation(fields: [taskId], references: [id])

  @@schema("slopwork")
}

model CampaignSubmission {
  id                      String                   @id @default(cuid())
  taskId                  String
  submitterId             String
  postUrl                 String
  xPostId                 String
  viewCount               Int?
  viewsReadAt             DateTime?
  apiFeeTxSig             String?
  contentCheckPassed      Boolean?
  contentCheckExplanation String?
  payoutLamports          BigInt?
  status                  CampaignSubmissionStatus @default(PENDING_PAYMENT)
  rejectionReason         String?
  paymentTxSig            String?
  paymentProposalIndex    BigInt?
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt

  task                    Task                     @relation(fields: [taskId], references: [id])
  submitter               User                     @relation("CampaignSubmitter", fields: [submitterId], references: [id])

  @@unique([taskId, xPostId])
  @@index([taskId])
  @@index([submitterId])
  @@index([status])
  @@schema("slopwork")
}

model KloutScore {
  id        String  @id
  name      String?
  username  String?
  image     String?
  twitterId String?
  score     Float   @default(0)
  rank      Int

  @@index([score])
  @@schema("slopwork")
}
